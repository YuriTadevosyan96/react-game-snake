{"version":3,"sources":["components/GameExplanation/GameExplanation.js","components/GameBoardCell/GameBoardCell.js","components/GameBoardCells/GameBoardCells.js","components/GameBoard/GameBoard.js","components/GameOver/GameOver.js","components/StartOrRestartGame/StartOrRestartGame.js","components/Score/Score.js","containers/GameLogic/GameLogic.js","App.js","index.js","components/GameBoardCell/GameBoardCell.module.css","components/GameBoard/GameBoard.module.css","components/GameOver/GameOver.module.css","components/Score/Score.module.css"],"names":["GameExplanation","Grid","GridRow","style","paddingBottom","GridColumn","textAlign","Icon","name","size","color","Header","as","GameBoardCell","isFoodCell","isSnakeBodyPart","isSnakeHead","appliedClasses","classes","push","SnakeHead","SnakeBodyPart","FoodCell","className","join","GameBoardCells","totalCellAmount","foodCellIndex","snakeBodyIndexes","isMaxScoreReached","Array","fill","map","_","cellIndex","some","snakeBodyPartIndex","GameBoard","gameBoardRows","gameBoardColumns","GameBoardStyles","gridTemplateRows","gridTemplateColumns","GameOver","StartOrRestartGame","handler","isStart","Button","onClick","Score","score","gameInitialState","snakeBodyCords","row","column","direction","snakeHeadDirection","gameScore","gameOver","startGame","restartGame","gameControlReducer","state","action","type","payload","setFoodCellIndexInitialState","updateSnakeHeadDirectionState","runGameLogic","Error","generateNotOccupiedCellIndex","gameState","updatedSnakeBodyCords","generateRandomFoodCellIndex","Math","floor","GAME_BOARD_ROWS","random","calcSnakeBodyPartIndexZeroBased","cords","isFoodCellIndexMatchingWithSnakeBodyCords","bodyPartCords","randomFoodCellIndex","console","log","convertSnakeBodyCordsToZeroBasedIndexes","snakeBodyPartCords","isGameOver","snakeHeadCords","GAME_BOARD_COLUMNS","isSnakeHeadHitTheWall","length","isSnakeHeadOverlapItsOwnBody","snakeBodyCordsUpdated","prevPartDirection","updateSnakeBodyPartDirection","previousPartDirection","updateSnakeBodyCordsBasedOnDirection","GAME_BOARD_TOTAL_CELLS","isSnakeHeadIndexMatchWithFoodCellIndex","updateGameStateSnakeHeadOnFoodCell","GameLogic","useReducer","dispatch","useState","gameCycleIntervalId","setGameCycleIntervalId","gameControlKeyDownHandler","useCallback","event","isCurrentDirectionUpOrDown","isCurrentDirectionLeftOrRight","key","useEffect","gameCycle","setInterval","clearInterval","document","addEventListener","once","removeEventListener","startGameHandler","restartGameHandler","App","ReactDOM","render","getElementById","module","exports"],"mappings":"8QA2BeA,EAxBS,WACtB,OACE,qCACE,eAACC,EAAA,EAAD,WACE,cAACC,EAAA,EAAD,CAASC,MAAO,CAAEC,cAAe,GAAjC,SACE,cAACC,EAAA,EAAD,CAAYC,UAAU,SAAtB,SACE,cAACC,EAAA,EAAD,CAAMC,KAAK,oCAAoCC,KAAK,OAAOC,MAAM,aAGrE,cAACR,EAAA,EAAD,UACE,eAACG,EAAA,EAAD,CAAYC,UAAU,SAAtB,UACE,cAACC,EAAA,EAAD,CAAMC,KAAK,sCAAsCC,KAAK,OAAOC,MAAM,SACnE,cAACH,EAAA,EAAD,CAAMC,KAAK,sCAAsCC,KAAK,OAAOC,MAAM,SACnE,cAACH,EAAA,EAAD,CAAMC,KAAK,uCAAuCC,KAAK,OAAOC,MAAM,iBAI1E,cAACC,EAAA,EAAD,CAAQL,UAAU,SAASM,GAAG,KAAKF,MAAM,OAAzC,gE,iBCJSG,EAZO,SAAC,GAAkD,IAAhDC,EAA+C,EAA/CA,WAAYC,EAAmC,EAAnCA,gBAAiBC,EAAkB,EAAlBA,YAC9CC,EAAiB,CAACC,IAAQL,eAQhC,OAPIG,EACFC,EAAeE,KAAKD,IAAQE,WACnBL,EACTE,EAAeE,KAAKD,IAAQG,eACnBP,GACTG,EAAeE,KAAKD,IAAQI,UAEvB,qBAAKC,UAAWN,EAAeO,KAAK,QCmB9BC,EA5BQ,SAAC,GAKjB,IAJLC,EAII,EAJJA,gBACAC,EAGI,EAHJA,cACAC,EAEI,EAFJA,iBACAC,EACI,EADJA,kBAIA,OAFuB,IAAIC,MAAMJ,GAAiBK,OAE5BC,KAAI,SAACC,EAAGC,GAC5B,IAAInB,EAAkBa,EAAiBO,MACrC,SAACC,GAAD,OAAwBA,IAAuBF,KAOjD,OAJIL,IACFd,GAAkB,GAIlB,cAAC,EAAD,CAEEC,YAAaY,EAAiB,KAAOM,EACrCpB,WAAYa,IAAkBO,EAC9BnB,gBAAiBA,GAHZmB,O,iBCOEG,EAzBG,SAAC,GAOZ,IANLC,EAMI,EANJA,cACAC,EAKI,EALJA,iBACAb,EAII,EAJJA,gBACAC,EAGI,EAHJA,cACAC,EAEI,EAFJA,iBACAC,EACI,EADJA,kBAEMW,EAAkB,CACtBC,iBAAiB,UAAD,OAAYH,EAAZ,UAChBI,oBAAoB,UAAD,OAAYH,EAAZ,WAGrB,OACE,qBAAKpC,MAAOqC,EAAiBjB,UAAWL,IAAQmB,UAAhD,SACE,cAAC,EAAD,CACEX,gBAAiBA,EACjBE,iBAAkBA,EAClBD,cAAeA,EACfE,kBAAmBA,O,iBChBZc,EAJE,WACf,OAAO,oBAAIpB,UAAWL,IAAQyB,SAAvB,wB,SCYMC,EAdY,SAAC,GAA0B,IAAxBC,EAAuB,EAAvBA,QAASC,EAAc,EAAdA,QACrC,OACE,cAAC7C,EAAA,EAAD,UACE,cAACC,EAAA,EAAD,UACE,cAACG,EAAA,EAAD,CAAYC,UAAU,SAAtB,SACE,cAACyC,EAAA,EAAD,CAAQtC,KAAK,OAAOuC,QAASH,EAA7B,SACGC,EAAU,aAAe,wB,iBCIvBG,EATD,SAAC,GAAkC,IAAhCC,EAA+B,EAA/BA,MAAOrB,EAAwB,EAAxBA,kBACtB,OACE,qBAAIN,UAAWL,IAAQ+B,MAAvB,UACGpB,EAAoB,6CAA+C,kBACnEqB,MCKDC,EAAmB,CACvBC,eAAgB,CACd,CAAEC,IAAK,EAAGC,OAAQ,EAAGC,UAAW,MAChC,CAAEF,IAAK,EAAGC,OAAQ,EAAGC,UAAW,OAElCC,mBAAoB,KACpBC,UAAW,EACX9B,cAAe,KACf+B,UAAU,EACV7B,mBAAmB,EACnB8B,WAAW,EACXC,YAAa,IAGTC,EAAqB,SAACC,EAAOC,GACjC,IAAQC,EAAkBD,EAAlBC,KAAMC,EAAYF,EAAZE,QACd,OAAQD,GACN,IAAK,aACH,OAAOL,IACT,IAAK,8BACH,OAAOO,EAA6BJ,GACtC,IAAK,8BACH,OAAOK,EAA8BL,EAAOG,GAC9C,IAAK,iBACH,OAAOG,EAAaN,GACtB,IAAK,eACH,OAAOF,IACT,QACE,MAAM,IAAIS,MAAM,mCAIhBV,EAAY,WAChB,OAAO,2BAAKR,GAAZ,IAA8BQ,WAAW,KAGrCC,EAAc,WAClB,OAAO,2BAAKT,GAAZ,IAA8BQ,WAAW,EAAMC,YAAa,MAGxDM,EAA+B,SAACJ,GACpC,OAAO,2BACFA,GADL,IAEEnC,cAAe2C,EAA6BR,EAAMV,mBAIhDe,EAAgC,SAACI,EAAWhB,GAChD,IAAMiB,EAAqB,YAAOD,EAAUnB,gBAE5C,OADAoB,EAAsB,GAAtB,2BAAgCA,EAAsB,IAAtD,IAA0DjB,UAAWA,IAC9D,2BACFgB,GADL,IAEEnB,eAAgBoB,EAChBhB,mBAAoBD,KAIlBkB,EAA8B,WAClC,OAAOC,KAAKC,MA7DiBC,IA6DXF,KAAKG,WAGnBC,EAAkC,SAACC,GAGvC,OApEyB,IAkEDA,EAAhB1B,IACa,GADG0B,EAAXzB,OAEE,GAGX0B,EAA4C,SAAC5B,EAAgBzB,GACjE,OAAOyB,EAAejB,MAAK,SAAC8C,GAG1B,OAF2BH,EAAgCG,KAE7BtD,MAI5B2C,EAA+B,SAAClB,GAGpC,IAFA,IAAI8B,EAAsBT,IAEnBO,EAA0C5B,EAAgB8B,IAC/DC,QAAQC,IAAI,gCACZF,EAAsBT,IAGxB,OAAOS,GAGHG,EAA0C,SAACjC,GAC/C,OAAOA,EAAepB,KAAI,SAACsD,GAAD,OACxBR,EAAgCQ,OA2B9BC,EAAa,SAACnC,GAClB,IAAMoC,EAAiBpC,EAAe,GACtC,OAzB4B,SAACoC,GAC7B,IAAQnC,EAAgBmC,EAAhBnC,IAAKC,EAAWkC,EAAXlC,OAEb,OACU,IAARD,GAAqBuB,KAARvB,GAA0C,IAAXC,GAA2BmC,KAAXnC,EAsB5DoC,CAAsBF,IAlBW,SAACpC,EAAgBoC,GACpD,IACE,IAAIpD,EAAqB,EACzBA,EAAqBgB,EAAeuC,OACpCvD,IAEA,GACE0C,EAAgC1B,EAAehB,MAC/C0C,EAAgCU,GAEhC,OAAO,EASTI,CAA6BxC,EAAgBoC,IAwE3CpB,EAAe,SAACG,GACpB,IAAQnB,EAAiEmB,EAAjEnB,eAAgBI,EAAiDe,EAAjDf,mBAAoB7B,EAA6B4C,EAA7B5C,cAAe8B,EAAcc,EAAdd,UAErDoC,EA5CqC,SAACzC,EAAgBI,GAQ5D,IAPA,IAMIsC,EANED,EAAwB,GAExBE,EAA+B,SAACC,EAAuB3C,EAAKC,GAChEuC,EAAsB1E,KAAK,CAAEoC,UAAWyC,EAAuB3C,MAAKC,YAKhElB,EAAqB,EACzBA,EAAqBgB,EAAeuC,OACpCvD,IACA,CACA,MAAmCgB,EAAehB,GAA1CiB,EAAR,EAAQA,IAAKC,EAAb,EAAaA,OAAQC,EAArB,EAAqBA,UAQrB,OALEuC,EADE1D,EAAqB,EACHgB,EAAehB,EAAqB,GAAGmB,UAEvCC,EAGdD,GACN,IAAK,KACHwC,EAA6BD,EAAmBzC,EAAM,EAAGC,GACzD,MACF,IAAK,OACHyC,EAA6BD,EAAmBzC,EAAM,EAAGC,GACzD,MACF,IAAK,OACHyC,EAA6BD,EAAmBzC,EAAKC,EAAS,GAC9D,MACF,IAAK,QACHyC,EAA6BD,EAAmBzC,EAAKC,EAAS,IAMpE,OAAOuC,EAMuBI,CAC5B7C,EACAI,GAGF,OA3DwB,SAACJ,EAAgBzB,GACzC,IAAM6D,EAAiBpC,EAAe,GACtC,GAA8B8C,MAA1B9C,EAAeuC,QACMb,EAAgCU,KAChC7D,EACrB,OAAO,EAsDPE,CAAkBgE,EAAuBlE,GACpC,2BACF4C,GADL,IAEEnB,eAAgByC,EAChBhE,mBAAmB,EACnB4B,UAAWA,EAAY,IAIvB8B,EAAWM,GACN,2BAAKtB,GAAZ,IAAuBb,UAAU,IAtFU,SAAC8B,EAAgB7D,GAG9D,OAFuBmD,EAAgCU,KAE7B7D,EAsFtBwE,CAAuCN,EAAsB,GAAIlE,GAnF5B,SAAC4C,EAAWiB,GACrD,IAAMK,EAAqB,CAAIL,GAAJ,mBAAuBjB,EAAUnB,iBAE5D,OAAO,2BACFmB,GADL,IAEEnB,eAAgByC,EAChBlE,cAAe2C,EAA6BuB,GAC5CpC,UAAWc,EAAUd,UAAY,IA6E1B2C,CAAmC7B,EAAWsB,EAAsB,IAGtE,2BAAKtB,GAAZ,IAAuBnB,eAAgByC,KAqG1BQ,EA1FG,WAChB,MAA8BC,qBAAWzC,EAAoBV,GAA7D,mBAAOoB,EAAP,KAAkBgC,EAAlB,KACA,EAAsDC,mBAAS,MAA/D,mBAAOC,EAAP,KAA4BC,EAA5B,KAGEtD,EAQEmB,EARFnB,eACAI,EAOEe,EAPFf,mBACAC,EAMEc,EANFd,UACA9B,EAKE4C,EALF5C,cACA+B,EAIEa,EAJFb,SACA7B,EAGE0C,EAHF1C,kBACA8B,EAEEY,EAFFZ,UACAC,EACEW,EADFX,YAGI+C,EAA4BC,uBAChC,SAACC,GACC,IAAMC,EACmB,OAAvBtD,GAAsD,SAAvBA,EAC3BuD,EACmB,SAAvBvD,GAAwD,UAAvBA,EAEnC,OAAQqD,EAAMG,KACZ,IAAK,UACCD,GACFR,EAAS,CAAEvC,KAAM,8BAA+BC,QAAS,OAC3D,MACF,IAAK,YACC8C,GACFR,EAAS,CAAEvC,KAAM,8BAA+BC,QAAS,SAC3D,MACF,IAAK,YACC6C,GACFP,EAAS,CAAEvC,KAAM,8BAA+BC,QAAS,SAC3D,MACF,IAAK,aACC6C,GACFP,EAAS,CAAEvC,KAAM,8BAA+BC,QAAS,aAKjE,CAACT,IA2BH,OAxBAyD,qBAAU,WACR,GAAItD,EAAW,CACb4C,EAAS,CAAEvC,KAAM,gCAEjB,IAAMkD,EAAYC,aAAY,WAC5BZ,EAAS,CAAEvC,KAAM,qBAvRE,KA4RrB,OAFA0C,EAAuBQ,GAEhB,kBAAME,cAAcF,OAE5B,CAACtD,EAAaD,IAEjBsD,qBAAU,WAOR,OANIvD,GAAY7B,IACduF,cAAcX,GAGhBY,SAASC,iBAAiB,UAAWX,EAA2B,CAAEY,MAAM,IAEjE,kBAAMF,SAASG,oBAAoB,UAAWb,EAA2B,CAAEY,MAAM,OACvF,CAACnE,EAAgBvB,IAGlB,qCACG6B,GAAY,cAAC,EAAD,KACXC,GAAa,cAAC,EAAD,IACf,cAAC,EAAD,CAAOT,MAAOO,EAAW5B,kBAAmBA,KAC1C8B,GAAa,cAAC,EAAD,CAAoBb,SAAO,EAACD,QAAS,kBA9EjC,SAAC0D,GACxBA,EAAS,CAAEvC,KAAM,eA6E6CyD,CAAiBlB,MAC1E7C,GAAY7B,EACX,cAAC,EAAD,CAAoBgB,QAAS,kBApFV,SAAC0D,GAC1BA,EAAS,CAAEvC,KAAM,iBAmFwB0D,CAAmBnB,MACpD,KACJ,cAAC,EAAD,CACEjE,cAvTgB,GAwThBC,iBAvTmB,GAwTnBb,gBAvTuBkD,IAwTvBjD,cAAeA,EACfE,kBAAmBA,EACnBD,iBAAkByD,EAAwCjC,SC5TnDuE,EAJH,WACV,OAAO,cAAC,EAAD,KCCTC,IAASC,OAAO,cAAC,EAAD,IAASR,SAASS,eAAe,U,mBCLjDC,EAAOC,QAAU,CAAC,cAAgB,qCAAqC,SAAW,gCAAgC,cAAgB,qCAAqC,UAAY,mC,mBCAnLD,EAAOC,QAAU,CAAC,UAAY,+B,mBCA9BD,EAAOC,QAAU,CAAC,SAAW,6B,mBCA7BD,EAAOC,QAAU,CAAC,MAAQ,wB","file":"static/js/main.f2288e78.chunk.js","sourcesContent":["import React from 'react';\r\nimport { Icon, Grid, GridRow, GridColumn, Header } from 'semantic-ui-react';\r\n\r\nconst GameExplanation = () => {\r\n  return (\r\n    <>\r\n      <Grid>\r\n        <GridRow style={{ paddingBottom: 0 }}>\r\n          <GridColumn textAlign=\"center\">\r\n            <Icon name=\"arrow alternate circle up outline\" size=\"huge\" color=\"grey\" />\r\n          </GridColumn>\r\n        </GridRow>\r\n        <GridRow>\r\n          <GridColumn textAlign=\"center\">\r\n            <Icon name=\"arrow alternate circle left outline\" size=\"huge\" color=\"grey\" />\r\n            <Icon name=\"arrow alternate circle down outline\" size=\"huge\" color=\"grey\" />\r\n            <Icon name=\"arrow alternate circle right outline\" size=\"huge\" color=\"grey\" />\r\n          </GridColumn>\r\n        </GridRow>\r\n      </Grid>\r\n      <Header textAlign=\"center\" as=\"h3\" color=\"grey\">\r\n        Use arrow keys on keyboard to control the game\r\n      </Header>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default GameExplanation;\r\n","import React from 'react';\r\n\r\nimport classes from './GameBoardCell.module.css';\r\n\r\nconst GameBoardCell = ({ isFoodCell, isSnakeBodyPart, isSnakeHead }) => {\r\n  const appliedClasses = [classes.GameBoardCell];\r\n  if (isSnakeHead) {\r\n    appliedClasses.push(classes.SnakeHead);\r\n  } else if (isSnakeBodyPart) {\r\n    appliedClasses.push(classes.SnakeBodyPart);\r\n  } else if (isFoodCell) {\r\n    appliedClasses.push(classes.FoodCell);\r\n  }\r\n  return <div className={appliedClasses.join(' ')}></div>;\r\n};\r\n\r\nexport default GameBoardCell;\r\n","import React from 'react';\r\n\r\nimport GameCell from '../GameBoardCell/GameBoardCell';\r\n\r\nconst GameBoardCells = ({\r\n  totalCellAmount,\r\n  foodCellIndex,\r\n  snakeBodyIndexes,\r\n  isMaxScoreReached,\r\n}) => {\r\n  const gameBoardCells = new Array(totalCellAmount).fill();\r\n\r\n  return gameBoardCells.map((_, cellIndex) => {\r\n    let isSnakeBodyPart = snakeBodyIndexes.some(\r\n      (snakeBodyPartIndex) => snakeBodyPartIndex === cellIndex\r\n    );\r\n\r\n    if (isMaxScoreReached) {\r\n      isSnakeBodyPart = true;\r\n    }\r\n\r\n    return (\r\n      <GameCell\r\n        key={cellIndex}\r\n        isSnakeHead={snakeBodyIndexes[0] === cellIndex}\r\n        isFoodCell={foodCellIndex === cellIndex}\r\n        isSnakeBodyPart={isSnakeBodyPart}\r\n      />\r\n    );\r\n  });\r\n};\r\n\r\nexport default GameBoardCells;\r\n","import React from 'react';\r\n\r\nimport GameBoardCells from '../GameBoardCells/GameBoardCells';\r\nimport classes from './GameBoard.module.css';\r\n\r\nconst GameBoard = ({\r\n  gameBoardRows,\r\n  gameBoardColumns,\r\n  totalCellAmount,\r\n  foodCellIndex,\r\n  snakeBodyIndexes,\r\n  isMaxScoreReached,\r\n}) => {\r\n  const GameBoardStyles = {\r\n    gridTemplateRows: `repeat(${gameBoardRows}, 1fr)`,\r\n    gridTemplateColumns: `repeat(${gameBoardColumns}, 1fr)`,\r\n  };\r\n\r\n  return (\r\n    <div style={GameBoardStyles} className={classes.GameBoard}>\r\n      <GameBoardCells\r\n        totalCellAmount={totalCellAmount}\r\n        snakeBodyIndexes={snakeBodyIndexes}\r\n        foodCellIndex={foodCellIndex}\r\n        isMaxScoreReached={isMaxScoreReached}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GameBoard;\r\n","import React from 'react';\r\n\r\nimport classes from './GameOver.module.css';\r\n\r\nconst GameOver = () => {\r\n  return <h2 className={classes.GameOver}>GAME OVER</h2>;\r\n};\r\n\r\nexport default GameOver;\r\n","import React from 'react';\r\nimport { Button, Grid, GridRow, GridColumn } from 'semantic-ui-react';\r\n\r\nconst StartOrRestartGame = ({ handler, isStart }) => {\r\n  return (\r\n    <Grid>\r\n      <GridRow>\r\n        <GridColumn textAlign=\"center\">\r\n          <Button size=\"huge\" onClick={handler}>\r\n            {isStart ? 'Start Game' : 'Restart Game'}\r\n          </Button>\r\n        </GridColumn>\r\n      </GridRow>\r\n    </Grid>\r\n  );\r\n};\r\n\r\nexport default StartOrRestartGame;\r\n","import React from 'react';\r\n\r\nimport classes from './Score.module.css';\r\n\r\nconst Score = ({ score, isMaxScoreReached }) => {\r\n  return (\r\n    <h2 className={classes.Score}>\r\n      {isMaxScoreReached ? 'Congratulations you reached maximum score ' : 'Current Score: '}\r\n      {score}\r\n    </h2>\r\n  );\r\n};\r\n\r\nexport default Score;\r\n","import React, { useEffect, useReducer, useState, useCallback } from 'react';\r\n\r\nimport GameExplanation from '../../components/GameExplanation/GameExplanation';\r\nimport GameBoard from '../../components/GameBoard/GameBoard';\r\nimport GameOver from '../../components/GameOver/GameOver';\r\nimport StartOrRestartGame from '../../components/StartOrRestartGame/StartOrRestartGame';\r\nimport Score from '../../components/Score/Score';\r\n\r\nconst GAME_BOARD_ROWS = 10;\r\nconst GAME_BOARD_COLUMNS = 11;\r\nconst GAME_BOARD_TOTAL_CELLS = GAME_BOARD_ROWS * GAME_BOARD_COLUMNS;\r\nconst GAME_STEP_INTERVAL = 500; // milliseconds\r\n\r\nconst gameInitialState = {\r\n  snakeBodyCords: [\r\n    { row: 5, column: 6, direction: 'UP' },\r\n    { row: 6, column: 6, direction: 'UP' },\r\n  ], // [{row: Number, column: Number, direction: enum(UP, DOWN, LEFT, RIGHT)}, ...]\r\n  snakeHeadDirection: 'UP', // enum(UP, DOWN, LEFT, RIGHT)\r\n  gameScore: 0,\r\n  foodCellIndex: null,\r\n  gameOver: false,\r\n  isMaxScoreReached: false,\r\n  startGame: false,\r\n  restartGame: {}, // object is used to easily change reference\r\n};\r\n\r\nconst gameControlReducer = (state, action) => {\r\n  const { type, payload } = action;\r\n  switch (type) {\r\n    case 'START_GAME':\r\n      return startGame();\r\n    case 'SET_FOOD_CELL_INITIAL_INDEX':\r\n      return setFoodCellIndexInitialState(state);\r\n    case 'CHANGE_SNAKE_HEAD_DIRECTION':\r\n      return updateSnakeHeadDirectionState(state, payload);\r\n    case 'RUN_GAME_LOGIC':\r\n      return runGameLogic(state);\r\n    case 'RESTART_GAME':\r\n      return restartGame();\r\n    default:\r\n      throw new Error('Unknown action type provided!');\r\n  }\r\n};\r\n\r\nconst startGame = () => {\r\n  return { ...gameInitialState, startGame: true };\r\n};\r\n\r\nconst restartGame = () => {\r\n  return { ...gameInitialState, startGame: true, restartGame: {} }; // changing object reference for restartGame to cause state update\r\n};\r\n\r\nconst setFoodCellIndexInitialState = (state) => {\r\n  return {\r\n    ...state,\r\n    foodCellIndex: generateNotOccupiedCellIndex(state.snakeBodyCords),\r\n  };\r\n};\r\n\r\nconst updateSnakeHeadDirectionState = (gameState, direction) => {\r\n  const updatedSnakeBodyCords = [...gameState.snakeBodyCords];\r\n  updatedSnakeBodyCords[0] = { ...updatedSnakeBodyCords[0], direction: direction };\r\n  return {\r\n    ...gameState,\r\n    snakeBodyCords: updatedSnakeBodyCords,\r\n    snakeHeadDirection: direction,\r\n  };\r\n};\r\n\r\nconst generateRandomFoodCellIndex = () => {\r\n  return Math.floor(Math.random() * GAME_BOARD_TOTAL_CELLS);\r\n};\r\n\r\nconst calcSnakeBodyPartIndexZeroBased = (cords) => {\r\n  const { row, column } = cords;\r\n  const index = (row - 1) * GAME_BOARD_COLUMNS + column;\r\n  return index - 1;\r\n};\r\n\r\nconst isFoodCellIndexMatchingWithSnakeBodyCords = (snakeBodyCords, foodCellIndex) => {\r\n  return snakeBodyCords.some((bodyPartCords) => {\r\n    const snakeBodyPartIndex = calcSnakeBodyPartIndexZeroBased(bodyPartCords);\r\n\r\n    return snakeBodyPartIndex === foodCellIndex;\r\n  });\r\n};\r\n\r\nconst generateNotOccupiedCellIndex = (snakeBodyCords) => {\r\n  let randomFoodCellIndex = generateRandomFoodCellIndex();\r\n\r\n  while (isFoodCellIndexMatchingWithSnakeBodyCords(snakeBodyCords, randomFoodCellIndex)) {\r\n    console.log('random index cell regenerate'); // logged because potential infinite loop logic is implemented\r\n    randomFoodCellIndex = generateRandomFoodCellIndex();\r\n  }\r\n\r\n  return randomFoodCellIndex;\r\n};\r\n\r\nconst convertSnakeBodyCordsToZeroBasedIndexes = (snakeBodyCords) => {\r\n  return snakeBodyCords.map((snakeBodyPartCords) =>\r\n    calcSnakeBodyPartIndexZeroBased(snakeBodyPartCords)\r\n  );\r\n};\r\n\r\nconst isSnakeHeadHitTheWall = (snakeHeadCords) => {\r\n  const { row, column } = snakeHeadCords;\r\n\r\n  return (\r\n    row === 0 || row === GAME_BOARD_ROWS + 1 || column === 0 || column === GAME_BOARD_COLUMNS + 1\r\n  );\r\n};\r\n\r\nconst isSnakeHeadOverlapItsOwnBody = (snakeBodyCords, snakeHeadCords) => {\r\n  for (\r\n    let snakeBodyPartIndex = 1;\r\n    snakeBodyPartIndex < snakeBodyCords.length;\r\n    snakeBodyPartIndex++\r\n  ) {\r\n    if (\r\n      calcSnakeBodyPartIndexZeroBased(snakeBodyCords[snakeBodyPartIndex]) ===\r\n      calcSnakeBodyPartIndexZeroBased(snakeHeadCords)\r\n    ) {\r\n      return true;\r\n    }\r\n  }\r\n};\r\n\r\nconst isGameOver = (snakeBodyCords) => {\r\n  const snakeHeadCords = snakeBodyCords[0];\r\n  return (\r\n    isSnakeHeadHitTheWall(snakeHeadCords) ||\r\n    isSnakeHeadOverlapItsOwnBody(snakeBodyCords, snakeHeadCords)\r\n  );\r\n};\r\n\r\nconst isSnakeHeadIndexMatchWithFoodCellIndex = (snakeHeadCords, foodCellIndex) => {\r\n  const snakeHeadIndex = calcSnakeBodyPartIndexZeroBased(snakeHeadCords);\r\n\r\n  return snakeHeadIndex === foodCellIndex;\r\n};\r\n\r\nconst updateGameStateSnakeHeadOnFoodCell = (gameState, snakeHeadCords) => {\r\n  const snakeBodyCordsUpdated = [snakeHeadCords, ...gameState.snakeBodyCords];\r\n\r\n  return {\r\n    ...gameState,\r\n    snakeBodyCords: snakeBodyCordsUpdated,\r\n    foodCellIndex: generateNotOccupiedCellIndex(snakeBodyCordsUpdated),\r\n    gameScore: gameState.gameScore + 1,\r\n  };\r\n};\r\n\r\nconst isMaxScoreReached = (snakeBodyCords, foodCellIndex) => {\r\n  const snakeHeadCords = snakeBodyCords[0];\r\n  if (snakeBodyCords.length === GAME_BOARD_TOTAL_CELLS - 1) {\r\n    const snakeHeadIndex = calcSnakeBodyPartIndexZeroBased(snakeHeadCords);\r\n    if (snakeHeadIndex === foodCellIndex) {\r\n      return true;\r\n    }\r\n  }\r\n};\r\n\r\nconst updateSnakeBodyCordsBasedOnDirection = (snakeBodyCords, snakeHeadDirection) => {\r\n  const snakeBodyCordsUpdated = [];\r\n\r\n  const updateSnakeBodyPartDirection = (previousPartDirection, row, column) => {\r\n    snakeBodyCordsUpdated.push({ direction: previousPartDirection, row, column });\r\n  };\r\n\r\n  let prevPartDirection;\r\n  for (\r\n    let snakeBodyPartIndex = 0;\r\n    snakeBodyPartIndex < snakeBodyCords.length;\r\n    snakeBodyPartIndex++\r\n  ) {\r\n    const { row, column, direction } = snakeBodyCords[snakeBodyPartIndex];\r\n\r\n    if (snakeBodyPartIndex > 0) {\r\n      prevPartDirection = snakeBodyCords[snakeBodyPartIndex - 1].direction;\r\n    } else {\r\n      prevPartDirection = snakeHeadDirection;\r\n    }\r\n\r\n    switch (direction) {\r\n      case 'UP':\r\n        updateSnakeBodyPartDirection(prevPartDirection, row - 1, column);\r\n        break;\r\n      case 'DOWN':\r\n        updateSnakeBodyPartDirection(prevPartDirection, row + 1, column);\r\n        break;\r\n      case 'LEFT':\r\n        updateSnakeBodyPartDirection(prevPartDirection, row, column - 1);\r\n        break;\r\n      case 'RIGHT':\r\n        updateSnakeBodyPartDirection(prevPartDirection, row, column + 1);\r\n        break;\r\n      default:\r\n    }\r\n  }\r\n\r\n  return snakeBodyCordsUpdated;\r\n};\r\n\r\nconst runGameLogic = (gameState) => {\r\n  const { snakeBodyCords, snakeHeadDirection, foodCellIndex, gameScore } = gameState;\r\n\r\n  const snakeBodyCordsUpdated = updateSnakeBodyCordsBasedOnDirection(\r\n    snakeBodyCords,\r\n    snakeHeadDirection\r\n  );\r\n\r\n  if (isMaxScoreReached(snakeBodyCordsUpdated, foodCellIndex)) {\r\n    return {\r\n      ...gameState,\r\n      snakeBodyCords: snakeBodyCordsUpdated,\r\n      isMaxScoreReached: true,\r\n      gameScore: gameScore + 1,\r\n    };\r\n  }\r\n\r\n  if (isGameOver(snakeBodyCordsUpdated)) {\r\n    return { ...gameState, gameOver: true };\r\n  }\r\n\r\n  if (isSnakeHeadIndexMatchWithFoodCellIndex(snakeBodyCordsUpdated[0], foodCellIndex)) {\r\n    return updateGameStateSnakeHeadOnFoodCell(gameState, snakeBodyCordsUpdated[0]);\r\n  }\r\n\r\n  return { ...gameState, snakeBodyCords: snakeBodyCordsUpdated };\r\n};\r\n\r\nconst restartGameHandler = (dispatch) => {\r\n  dispatch({ type: 'RESTART_GAME' });\r\n};\r\n\r\nconst startGameHandler = (dispatch) => {\r\n  dispatch({ type: 'START_GAME' });\r\n};\r\n\r\nconst GameLogic = () => {\r\n  const [gameState, dispatch] = useReducer(gameControlReducer, gameInitialState);\r\n  const [gameCycleIntervalId, setGameCycleIntervalId] = useState(null);\r\n\r\n  const {\r\n    snakeBodyCords,\r\n    snakeHeadDirection,\r\n    gameScore,\r\n    foodCellIndex,\r\n    gameOver,\r\n    isMaxScoreReached,\r\n    startGame,\r\n    restartGame,\r\n  } = gameState;\r\n\r\n  const gameControlKeyDownHandler = useCallback(\r\n    (event) => {\r\n      const isCurrentDirectionUpOrDown =\r\n        snakeHeadDirection === 'UP' || snakeHeadDirection === 'DOWN';\r\n      const isCurrentDirectionLeftOrRight =\r\n        snakeHeadDirection === 'LEFT' || snakeHeadDirection === 'RIGHT';\r\n\r\n      switch (event.key) {\r\n        case 'ArrowUp':\r\n          if (isCurrentDirectionLeftOrRight)\r\n            dispatch({ type: 'CHANGE_SNAKE_HEAD_DIRECTION', payload: 'UP' });\r\n          break;\r\n        case 'ArrowDown':\r\n          if (isCurrentDirectionLeftOrRight)\r\n            dispatch({ type: 'CHANGE_SNAKE_HEAD_DIRECTION', payload: 'DOWN' });\r\n          break;\r\n        case 'ArrowLeft':\r\n          if (isCurrentDirectionUpOrDown)\r\n            dispatch({ type: 'CHANGE_SNAKE_HEAD_DIRECTION', payload: 'LEFT' });\r\n          break;\r\n        case 'ArrowRight':\r\n          if (isCurrentDirectionUpOrDown)\r\n            dispatch({ type: 'CHANGE_SNAKE_HEAD_DIRECTION', payload: 'RIGHT' });\r\n          break;\r\n        default:\r\n      }\r\n    },\r\n    [snakeHeadDirection]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (startGame) {\r\n      dispatch({ type: 'SET_FOOD_CELL_INITIAL_INDEX' });\r\n\r\n      const gameCycle = setInterval(() => {\r\n        dispatch({ type: 'RUN_GAME_LOGIC' });\r\n      }, GAME_STEP_INTERVAL);\r\n\r\n      setGameCycleIntervalId(gameCycle);\r\n\r\n      return () => clearInterval(gameCycle);\r\n    }\r\n  }, [restartGame, startGame]);\r\n\r\n  useEffect(() => {\r\n    if (gameOver || isMaxScoreReached) {\r\n      clearInterval(gameCycleIntervalId);\r\n    }\r\n\r\n    document.addEventListener('keydown', gameControlKeyDownHandler, { once: true });\r\n\r\n    return () => document.removeEventListener('keydown', gameControlKeyDownHandler, { once: true });\r\n  }, [snakeBodyCords, isMaxScoreReached]);\r\n\r\n  return (\r\n    <>\r\n      {gameOver && <GameOver />}\r\n      {!startGame && <GameExplanation />}\r\n      <Score score={gameScore} isMaxScoreReached={isMaxScoreReached} />\r\n      {!startGame && <StartOrRestartGame isStart handler={() => startGameHandler(dispatch)} />}\r\n      {gameOver || isMaxScoreReached ? (\r\n        <StartOrRestartGame handler={() => restartGameHandler(dispatch)} />\r\n      ) : null}\r\n      <GameBoard\r\n        gameBoardRows={GAME_BOARD_ROWS}\r\n        gameBoardColumns={GAME_BOARD_COLUMNS}\r\n        totalCellAmount={GAME_BOARD_TOTAL_CELLS}\r\n        foodCellIndex={foodCellIndex}\r\n        isMaxScoreReached={isMaxScoreReached}\r\n        snakeBodyIndexes={convertSnakeBodyCordsToZeroBasedIndexes(snakeBodyCords)}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\nexport default GameLogic;\r\n","import React from 'react';\r\n\r\nimport GameLogic from './containers/GameLogic/GameLogic';\r\n\r\nconst App = () => {\r\n  return <GameLogic />;\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport 'semantic-ui-css/semantic.min.css';\r\nimport './styles/index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"GameBoardCell\":\"GameBoardCell_GameBoardCell__2xIBz\",\"FoodCell\":\"GameBoardCell_FoodCell__1MRRB\",\"SnakeBodyPart\":\"GameBoardCell_SnakeBodyPart__2X-Qo\",\"SnakeHead\":\"GameBoardCell_SnakeHead__Gs9MP\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"GameBoard\":\"GameBoard_GameBoard__1-rkU\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"GameOver\":\"GameOver_GameOver__1baa_\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Score\":\"Score_Score__cfuHX\"};"],"sourceRoot":""}