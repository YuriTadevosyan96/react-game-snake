{"version":3,"sources":["components/GameBoardCell/GameBoardCell.module.css","components/GameBoard/GameBoard.module.css","components/GameOver/GameOver.module.css","components/RestartGame/RestartGame.module.css","components/Score/Score.module.css","components/GameBoardCell/GameBoardCell.js","components/GameBoardCells/GameBoardCells.js","components/GameBoard/GameBoard.js","components/GameOver/GameOver.js","components/RestartGame/RestartGame.js","components/Score/Score.js","containers/GameLogic/GameLogic.js","App.js","index.js"],"names":["module","exports","GameBoardCell","isFoodCell","isSnakeBodyPart","appliedClasses","classes","push","FoodCell","SnakeBodyPart","className","join","GameBoardCells","totalCellAmount","foodCellIndex","snakeBodyIndexes","isMaxScoreReached","Array","fill","map","_","cellIndex","some","snakeBodyPartIndex","GameBoard","gameBoardRows","gameBoardColumns","GameBoardStyles","gridTemplateRows","gridTemplateColumns","style","GameOver","RestartGame","restartHandler","onClick","type","Score","score","gameInitialState","snakeBodyCords","row","column","direction","snakeHeadDirection","gameScore","gameOver","restartGame","gameControlReducer","state","action","payload","setFoodCellIndexInitialState","updateSnakeHeadDirectionState","runGameLogic","Error","generateNotOccupiedCellIndex","gameState","updatedSnakeBodyCords","generateRandomFoodCellIndex","Math","floor","GAME_BOARD_ROWS","random","calcSnakeBodyPartIndexZeroBased","cords","isFoodCellIndexMatchingWithSnakeBodyCords","bodyPartCords","randomFoodCellIndex","console","log","convertSnakeBodyCordsToZeroBasedIndexes","snakeBodyPartCords","isGameOver","snakeHeadCords","GAME_BOARD_COLUMNS","isSnakeHeadHitTheWall","length","isSnakeHeadOverlapItsOwnBody","snakeBodyCordsUpdated","prevPartDirection","updateSnakeBodyPartDirection","previousPartDirection","updateSnakeBodyCordsBasedOnDirection","GAME_BOARD_TOTAL_CELLS","isSnakeHeadIndexMatchWithFoodCellIndex","updateGameStateSnakeHeadOnFoodCell","GameLogic","useReducer","dispatch","useState","gameCycleIntervalId","setGameCycleIntervalId","gameControlKeyDownHandler","useCallback","event","isCurrentDirectionUpOrDown","isCurrentDirectionLeftOrRight","key","useEffect","gameCycle","setInterval","clearInterval","document","addEventListener","once","removeEventListener","restartGameHandler","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.b34972d8.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"GameBoardCell\":\"GameBoardCell_GameBoardCell__2xIBz\",\"FoodCell\":\"GameBoardCell_FoodCell__1MRRB\",\"SnakeBodyPart\":\"GameBoardCell_SnakeBodyPart__2X-Qo\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"GameBoard\":\"GameBoard_GameBoard__1-rkU\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"GameOver\":\"GameOver_GameOver__1baa_\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"RestartGame\":\"RestartGame_RestartGame__3Ph1C\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Score\":\"Score_Score__cfuHX\"};","import React from 'react';\r\n\r\nimport classes from './GameBoardCell.module.css';\r\n\r\nconst GameBoardCell = ({ isFoodCell, isSnakeBodyPart }) => {\r\n  const appliedClasses = [classes.GameBoardCell];\r\n  if (isFoodCell) {\r\n    appliedClasses.push(classes.FoodCell);\r\n  } else if (isSnakeBodyPart) {\r\n    appliedClasses.push(classes.SnakeBodyPart);\r\n  }\r\n\r\n  return <div className={appliedClasses.join(' ')}></div>;\r\n};\r\n\r\nexport default GameBoardCell;\r\n","import React from 'react';\r\n\r\nimport GameCell from '../GameBoardCell/GameBoardCell';\r\n\r\nconst GameBoardCells = ({\r\n  totalCellAmount,\r\n  foodCellIndex,\r\n  snakeBodyIndexes,\r\n  isMaxScoreReached,\r\n}) => {\r\n  const gameBoardCells = new Array(totalCellAmount).fill();\r\n\r\n  return gameBoardCells.map((_, cellIndex) => {\r\n    let isSnakeBodyPart = snakeBodyIndexes.some(\r\n      (snakeBodyPartIndex) => snakeBodyPartIndex === cellIndex\r\n    );\r\n\r\n    if (isMaxScoreReached) {\r\n      isSnakeBodyPart = true;\r\n    }\r\n\r\n    return (\r\n      <GameCell\r\n        key={cellIndex}\r\n        isFoodCell={foodCellIndex === cellIndex && !isMaxScoreReached}\r\n        isSnakeBodyPart={isSnakeBodyPart}\r\n      />\r\n    );\r\n  });\r\n};\r\n\r\nexport default GameBoardCells;\r\n","import React from 'react';\r\n\r\nimport GameBoardCells from '../GameBoardCells/GameBoardCells';\r\nimport classes from './GameBoard.module.css';\r\n\r\nconst GameBoard = ({\r\n  gameBoardRows,\r\n  gameBoardColumns,\r\n  totalCellAmount,\r\n  foodCellIndex,\r\n  snakeBodyIndexes,\r\n  isMaxScoreReached,\r\n}) => {\r\n  const GameBoardStyles = {\r\n    gridTemplateRows: `repeat(${gameBoardRows}, 1fr)`,\r\n    gridTemplateColumns: `repeat(${gameBoardColumns}, 1fr)`,\r\n  };\r\n\r\n  return (\r\n    <div style={GameBoardStyles} className={classes.GameBoard}>\r\n      <GameBoardCells\r\n        totalCellAmount={totalCellAmount}\r\n        snakeBodyIndexes={snakeBodyIndexes}\r\n        foodCellIndex={foodCellIndex}\r\n        isMaxScoreReached={isMaxScoreReached}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GameBoard;\r\n","import React from 'react';\r\n\r\nimport classes from './GameOver.module.css';\r\n\r\nconst GameOver = () => {\r\n  return <h2 className={classes.GameOver}>GAME OVER</h2>;\r\n};\r\n\r\nexport default GameOver;\r\n","import React from 'react';\r\n\r\nimport classes from './RestartGame.module.css';\r\n\r\nconst RestartGame = ({ restartHandler }) => {\r\n  return (\r\n    <button onClick={restartHandler} className={classes.RestartGame} type=\"button\">\r\n      Restart Game\r\n    </button>\r\n  );\r\n};\r\n\r\nexport default RestartGame;\r\n","import React from 'react';\r\n\r\nimport classes from './Score.module.css';\r\n\r\nconst Score = ({ score, isMaxScoreReached }) => {\r\n  return (\r\n    <h2 className={classes.Score}>\r\n      {isMaxScoreReached ? 'Congratulations you reached maximum score ' : 'Current Score: '}\r\n      {score}\r\n    </h2>\r\n  );\r\n};\r\n\r\nexport default Score;\r\n","import React, { useEffect, useReducer, useState, useCallback } from 'react';\r\n\r\nimport GameBoard from '../../components/GameBoard/GameBoard';\r\nimport GameOver from '../../components/GameOver/GameOver';\r\nimport RestartGame from '../../components/RestartGame/RestartGame';\r\nimport Score from '../../components/Score/Score';\r\n\r\nconst GAME_BOARD_ROWS = 10;\r\nconst GAME_BOARD_COLUMNS = 11;\r\nconst GAME_BOARD_TOTAL_CELLS = GAME_BOARD_ROWS * GAME_BOARD_COLUMNS;\r\nconst GAME_STEP_INTERVAL = 500; // milliseconds\r\n\r\nconst gameInitialState = {\r\n  snakeBodyCords: [\r\n    { row: 5, column: 6, direction: 'UP' },\r\n    { row: 6, column: 6, direction: 'UP' },\r\n  ], // [{row: Number, column: Number, direction: enum(UP, DOWN, LEFT, RIGHT)}, ...]\r\n  snakeHeadDirection: 'UP', // enum(UP, DOWN, LEFT, RIGHT)\r\n  gameScore: 0,\r\n  foodCellIndex: null,\r\n  gameOver: false,\r\n  isMaxScoreReached: false,\r\n  restartGame: {}, // object is used to easily change reference\r\n};\r\n\r\nconst gameControlReducer = (state, action) => {\r\n  const { type, payload } = action;\r\n  switch (type) {\r\n    case 'SET_FOOD_CELL_INITIAL_INDEX':\r\n      return setFoodCellIndexInitialState(state);\r\n    case 'CHANGE_SNAKE_HEAD_DIRECTION':\r\n      return updateSnakeHeadDirectionState(state, payload);\r\n    case 'RUN_GAME_LOGIC':\r\n      return runGameLogic(state);\r\n    case 'RESTART_GAME':\r\n      return restartGame();\r\n    default:\r\n      throw new Error('Unknown action type provided!');\r\n  }\r\n};\r\n\r\nconst restartGame = () => {\r\n  return { ...gameInitialState, restartGame: {} }; // changing object reference for restartGame to cause state update\r\n};\r\n\r\nconst setFoodCellIndexInitialState = (state) => {\r\n  return {\r\n    ...state,\r\n    foodCellIndex: generateNotOccupiedCellIndex(state.snakeBodyCords),\r\n  };\r\n};\r\n\r\nconst updateSnakeHeadDirectionState = (gameState, direction) => {\r\n  const updatedSnakeBodyCords = [...gameState.snakeBodyCords];\r\n  updatedSnakeBodyCords[0] = { ...updatedSnakeBodyCords[0], direction: direction };\r\n  return {\r\n    ...gameState,\r\n    snakeBodyCords: updatedSnakeBodyCords,\r\n    snakeHeadDirection: direction,\r\n  };\r\n};\r\n\r\nconst generateRandomFoodCellIndex = () => {\r\n  return Math.floor(Math.random() * GAME_BOARD_TOTAL_CELLS);\r\n};\r\n\r\nconst calcSnakeBodyPartIndexZeroBased = (cords) => {\r\n  const { row, column } = cords;\r\n  const index = (row - 1) * GAME_BOARD_COLUMNS + column;\r\n  return index - 1;\r\n};\r\n\r\nconst isFoodCellIndexMatchingWithSnakeBodyCords = (snakeBodyCords, foodCellIndex) => {\r\n  return snakeBodyCords.some((bodyPartCords) => {\r\n    const snakeBodyPartIndex = calcSnakeBodyPartIndexZeroBased(bodyPartCords);\r\n\r\n    return snakeBodyPartIndex === foodCellIndex;\r\n  });\r\n};\r\n\r\nconst generateNotOccupiedCellIndex = (snakeBodyCords) => {\r\n  let randomFoodCellIndex = generateRandomFoodCellIndex();\r\n\r\n  while (isFoodCellIndexMatchingWithSnakeBodyCords(snakeBodyCords, randomFoodCellIndex)) {\r\n    console.log('random index cell regenerate'); // logged because potential infinite loop logic is implemented\r\n    randomFoodCellIndex = generateRandomFoodCellIndex();\r\n  }\r\n\r\n  return randomFoodCellIndex;\r\n};\r\n\r\nconst convertSnakeBodyCordsToZeroBasedIndexes = (snakeBodyCords) => {\r\n  return snakeBodyCords.map((snakeBodyPartCords) =>\r\n    calcSnakeBodyPartIndexZeroBased(snakeBodyPartCords)\r\n  );\r\n};\r\n\r\nconst isSnakeHeadHitTheWall = (snakeHeadCords) => {\r\n  const { row, column } = snakeHeadCords;\r\n\r\n  return (\r\n    row === 0 || row === GAME_BOARD_ROWS + 1 || column === 0 || column === GAME_BOARD_COLUMNS + 1\r\n  );\r\n};\r\n\r\nconst isSnakeHeadOverlapItsOwnBody = (snakeBodyCords, snakeHeadCords) => {\r\n  for (\r\n    let snakeBodyPartIndex = 1;\r\n    snakeBodyPartIndex < snakeBodyCords.length;\r\n    snakeBodyPartIndex++\r\n  ) {\r\n    if (\r\n      calcSnakeBodyPartIndexZeroBased(snakeBodyCords[snakeBodyPartIndex]) ===\r\n      calcSnakeBodyPartIndexZeroBased(snakeHeadCords)\r\n    ) {\r\n      return true;\r\n    }\r\n  }\r\n};\r\n\r\nconst isGameOver = (snakeBodyCords) => {\r\n  const snakeHeadCords = snakeBodyCords[0];\r\n  return (\r\n    isSnakeHeadHitTheWall(snakeHeadCords) ||\r\n    isSnakeHeadOverlapItsOwnBody(snakeBodyCords, snakeHeadCords)\r\n  );\r\n};\r\n\r\nconst isSnakeHeadIndexMatchWithFoodCellIndex = (snakeHeadCords, foodCellIndex) => {\r\n  const snakeHeadIndex = calcSnakeBodyPartIndexZeroBased(snakeHeadCords);\r\n\r\n  return snakeHeadIndex === foodCellIndex;\r\n};\r\n\r\nconst updateGameStateSnakeHeadOnFoodCell = (gameState, snakeHeadCords) => {\r\n  const snakeBodyCordsUpdated = [snakeHeadCords, ...gameState.snakeBodyCords];\r\n\r\n  return {\r\n    ...gameState,\r\n    snakeBodyCords: snakeBodyCordsUpdated,\r\n    foodCellIndex: generateNotOccupiedCellIndex(snakeBodyCordsUpdated),\r\n    gameScore: gameState.gameScore + 1,\r\n  };\r\n};\r\n\r\nconst isMaxScoreReached = (snakeBodyCords, foodCellIndex) => {\r\n  const snakeHeadCords = snakeBodyCords[0];\r\n  if (snakeBodyCords.length === GAME_BOARD_TOTAL_CELLS - 1) {\r\n    const snakeHeadIndex = calcSnakeBodyPartIndexZeroBased(snakeHeadCords);\r\n    if (snakeHeadIndex === foodCellIndex) {\r\n      return true;\r\n    }\r\n  }\r\n};\r\n\r\nconst updateSnakeBodyCordsBasedOnDirection = (snakeBodyCords, snakeHeadDirection) => {\r\n  const snakeBodyCordsUpdated = [];\r\n\r\n  const updateSnakeBodyPartDirection = (previousPartDirection, row, column) => {\r\n    snakeBodyCordsUpdated.push({ direction: previousPartDirection, row, column });\r\n  };\r\n\r\n  let prevPartDirection;\r\n  for (\r\n    let snakeBodyPartIndex = 0;\r\n    snakeBodyPartIndex < snakeBodyCords.length;\r\n    snakeBodyPartIndex++\r\n  ) {\r\n    const { row, column, direction } = snakeBodyCords[snakeBodyPartIndex];\r\n\r\n    if (snakeBodyPartIndex > 0) {\r\n      prevPartDirection = snakeBodyCords[snakeBodyPartIndex - 1].direction;\r\n    } else {\r\n      prevPartDirection = snakeHeadDirection;\r\n    }\r\n\r\n    switch (direction) {\r\n      case 'UP':\r\n        updateSnakeBodyPartDirection(prevPartDirection, row - 1, column);\r\n        break;\r\n      case 'DOWN':\r\n        updateSnakeBodyPartDirection(prevPartDirection, row + 1, column);\r\n        break;\r\n      case 'LEFT':\r\n        updateSnakeBodyPartDirection(prevPartDirection, row, column - 1);\r\n        break;\r\n      case 'RIGHT':\r\n        updateSnakeBodyPartDirection(prevPartDirection, row, column + 1);\r\n        break;\r\n      default:\r\n    }\r\n  }\r\n\r\n  return snakeBodyCordsUpdated;\r\n};\r\n\r\nconst runGameLogic = (gameState) => {\r\n  const { snakeBodyCords, snakeHeadDirection, foodCellIndex, gameScore } = gameState;\r\n\r\n  const snakeBodyCordsUpdated = updateSnakeBodyCordsBasedOnDirection(\r\n    snakeBodyCords,\r\n    snakeHeadDirection\r\n  );\r\n\r\n  if (isMaxScoreReached(snakeBodyCordsUpdated, foodCellIndex)) {\r\n    return { ...gameState, isMaxScoreReached: true, gameScore: gameScore + 1 };\r\n  }\r\n\r\n  if (isGameOver(snakeBodyCordsUpdated)) {\r\n    return { ...gameState, gameOver: true };\r\n  }\r\n\r\n  if (isSnakeHeadIndexMatchWithFoodCellIndex(snakeBodyCordsUpdated[0], foodCellIndex)) {\r\n    return updateGameStateSnakeHeadOnFoodCell(gameState, snakeBodyCordsUpdated[0]);\r\n  }\r\n\r\n  return { ...gameState, snakeBodyCords: snakeBodyCordsUpdated };\r\n};\r\n\r\nconst restartGameHandler = (dispatch) => {\r\n  dispatch({ type: 'RESTART_GAME' });\r\n};\r\n\r\nconst GameLogic = () => {\r\n  const [gameState, dispatch] = useReducer(gameControlReducer, gameInitialState);\r\n  const [gameCycleIntervalId, setGameCycleIntervalId] = useState(null);\r\n\r\n  const {\r\n    snakeBodyCords,\r\n    snakeHeadDirection,\r\n    gameScore,\r\n    foodCellIndex,\r\n    gameOver,\r\n    isMaxScoreReached,\r\n    restartGame,\r\n  } = gameState;\r\n\r\n  const gameControlKeyDownHandler = useCallback(\r\n    (event) => {\r\n      const isCurrentDirectionUpOrDown =\r\n        snakeHeadDirection === 'UP' || snakeHeadDirection === 'DOWN';\r\n      const isCurrentDirectionLeftOrRight =\r\n        snakeHeadDirection === 'LEFT' || snakeHeadDirection === 'RIGHT';\r\n\r\n      switch (event.key) {\r\n        case 'ArrowUp':\r\n          if (isCurrentDirectionLeftOrRight)\r\n            dispatch({ type: 'CHANGE_SNAKE_HEAD_DIRECTION', payload: 'UP' });\r\n          break;\r\n        case 'ArrowDown':\r\n          if (isCurrentDirectionLeftOrRight)\r\n            dispatch({ type: 'CHANGE_SNAKE_HEAD_DIRECTION', payload: 'DOWN' });\r\n          break;\r\n        case 'ArrowLeft':\r\n          if (isCurrentDirectionUpOrDown)\r\n            dispatch({ type: 'CHANGE_SNAKE_HEAD_DIRECTION', payload: 'LEFT' });\r\n          break;\r\n        case 'ArrowRight':\r\n          if (isCurrentDirectionUpOrDown)\r\n            dispatch({ type: 'CHANGE_SNAKE_HEAD_DIRECTION', payload: 'RIGHT' });\r\n          break;\r\n        default:\r\n      }\r\n    },\r\n    [snakeHeadDirection]\r\n  );\r\n\r\n  useEffect(() => {\r\n    dispatch({ type: 'SET_FOOD_CELL_INITIAL_INDEX' });\r\n\r\n    const gameCycle = setInterval(() => {\r\n      dispatch({ type: 'RUN_GAME_LOGIC' });\r\n    }, GAME_STEP_INTERVAL);\r\n\r\n    setGameCycleIntervalId(gameCycle);\r\n\r\n    return () => clearInterval(gameCycle);\r\n  }, [restartGame]);\r\n\r\n  useEffect(() => {\r\n    if (gameOver || isMaxScoreReached) {\r\n      clearInterval(gameCycleIntervalId);\r\n    }\r\n\r\n    document.addEventListener('keydown', gameControlKeyDownHandler, { once: true });\r\n\r\n    return () => document.removeEventListener('keydown', gameControlKeyDownHandler, { once: true });\r\n  }, [snakeBodyCords]);\r\n\r\n  return (\r\n    <>\r\n      {gameOver && <GameOver />}\r\n      <Score score={gameScore} isMaxScoreReached={isMaxScoreReached} />\r\n      {gameOver && <RestartGame restartHandler={() => restartGameHandler(dispatch)} />}\r\n      <GameBoard\r\n        gameBoardRows={GAME_BOARD_ROWS}\r\n        gameBoardColumns={GAME_BOARD_COLUMNS}\r\n        totalCellAmount={GAME_BOARD_TOTAL_CELLS}\r\n        foodCellIndex={foodCellIndex}\r\n        isMaxScoreReached={isMaxScoreReached}\r\n        snakeBodyIndexes={convertSnakeBodyCordsToZeroBasedIndexes(snakeBodyCords)}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\nexport default GameLogic;\r\n","import React from 'react';\r\n\r\nimport GameLogic from './containers/GameLogic/GameLogic';\r\n\r\nconst App = () => {\r\n  return <GameLogic />;\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './styles/index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}